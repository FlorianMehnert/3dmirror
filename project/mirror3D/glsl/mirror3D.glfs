#version 330 core

uniform bool render_quads;
uniform int coloring;
uniform sampler2D depth_image;

// *** adapted point.glfs ***

// vertex_position[4] contains position of passed triangle strip: t1: 0,1,2 - t2: 1,2,3 
in POINT_FS {
	vec2 uv;
	vec4 color;
	float depth_offset;
	vec3 vertex_position[4];
	vec3 normal;
	vec3 debug_color;
} fi;

//***** begin interface of fragment.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
void finish_fragment(vec4 color, float depth);
//***** end interface of fragment.glfs ***********************************

//***** begin interface of holo_disp.glfs ***********************************
void compute_sub_pixel_rays(out vec3 ro[3], out vec3 rd[3]);
bool finalize_sub_pixel_fragment(in vec3 rgb, in vec3 depth);
//***** end interface of holo_disp.glfs ***********************************

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

vec3 rayTracePixel(vec3 ro, vec3 rd, out float depth) {
	vec3 pos, nor; // hit position and normal
	vec3 col;
	int mat_id; // material ID
	//float t = intersect(ro, rd, pos, nor, mat_id);
	float t = 0.1;
	col = vec3(1.0, 0, 1.0);
	if(mat_id != -1) {
		// get color and texture coordinates depending on material
		vec4 material = vec4(1.0, 0.1, 0.1, 0.05); // add actual color calculation probabily just take given color
		
		/*
		somehow find out what the color is we collided with
		vec2 uv = get_texcoords(pos, mat_id);
		*/
		
		vec3 albedo = material.rgb;
		
		// lighting - probably not to be hardcoded 😎
		//color = compute_illumination(pos, nor, rd, shadow_factor, albedo);
		col = vec3(1.0, 0.1, 0.1);
	}
	
	vec4 pos_clip = get_modelview_projection_matrix() * vec4(pos, 1.0);
	depth = 0.5*(pos_clip.z / pos_clip.w) + 0.5;
	
	return col; 
}

void march_along(vec3 ro, vec3 rd, out vec3 color, out float depth){
	vec3 sample_point;
	const int max_steps = 100;
	const float max_distance = 100.0;

	float depth_threshold = texture(depth_image, gl_FragCoord.xy / vec2(textureSize(depth_image, 0))).r;
	float t = 0.0; // stepsize
	depth = 0.0;

	for (int i = 0; i < max_steps; i++) {
		sample_point = ro + rd * t;
		depth = texture(depth_image, sample_point.xy).r;
		if (depth < depth_threshold || t > max_distance) {
			break;
		}
		t += 0.01; // maybe adjust step size
	}

	if (depth < depth_threshold) {
		
		// intersection found, do shading calculations here
		vec3 intersection_point = ro + rd * t;
		// perform shading calculations...
        
		//return texture(color_image)vec4(1.0, 1.0, 1.0, 1.0); // Example color
		color =  vec4(0.0).xyz; //fi.color.xyz;
	} else {
		// No intersection found
		discard;
	}
}

void raymarch_detphtexture_from_anywhere(vec3 ro, vec3 rd, out vec3 color, out float depth){
	vec3 sample_point;
	const int max_steps = 100;
	const float max_distance = 100.0;
	bool previous_sample_type = false; // no surface

	float depth_threshold = texture(depth_image, gl_FragCoord.xy / vec2(textureSize(depth_image, 0))).r;
	float t = 0.0; // stepsize
	depth = 0.0;

	for (int i = 0; i < max_steps; i++) {
		sample_point = ro + rd * t;
		depth = texture(depth_image, sample_point.xy).r;
		if (depth < depth_threshold || t > max_distance) {
			break;
		}
		t += 0.01; // maybe adjust step size
	}

	if (depth < depth_threshold) {
		
		// intersection found, do shading calculations here
		vec3 intersection_point = ro + rd * t;
		// perform shading calculations...
        
		//return texture(color_image)vec4(1.0, 1.0, 1.0, 1.0); // Example color
		color =  vec4(0.0).xyz; //fi.color.xyz;
	} else {
		// No intersection found
		discard;
	}
}

void main()
{
	if (coloring == 0){
		finish_fragment(fi.color, gl_FragCoord.z + fi.depth_offset);
	} else if (coloring == 1) {

		// TODO: why is this factor 10000 -> pretty easy: small triangle = small normal -> only relative matters
		finish_fragment(vec4(fi.normal.xyz * 10000, 1.0), gl_FragCoord.z + fi.depth_offset);
	} else if (coloring == 2) {
		vec3 ro[3], rd[3];
		vec3 rgb;
		vec3 depth;

		compute_sub_pixel_rays(ro, rd);
		for (int i; i < 3; i++){
			march_along(ro[i], rd[i], rgb, depth[i]);
		}

		if (!finalize_sub_pixel_fragment(rgb, depth))
			discard;
	}
}