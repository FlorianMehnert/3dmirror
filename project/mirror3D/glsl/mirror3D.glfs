#version 330 core

uniform bool render_quads;
uniform int coloring;

// *** adapted point.glfs ***

// vertex_position[4] contains position of passed triangle strip: t1: 0,1,2 - t2: 1,2,3 
in POINT_FS {
	vec2 uv;
	vec4 color;
	float depth_offset;
	vec3 vertex_position[4];
	vec3 normal;
} fi;

//***** begin interface of fragment.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
void finish_fragment(vec4 color, float depth);
//***** end interface of fragment.glfs ***********************************

//***** begin interface of holo_disp.glfs ***********************************
void compute_sub_pixel_rays(out vec3 ro[3], out vec3 rd[3]);
bool finalize_sub_pixel_fragment(in vec3 rgb, in vec3 depth);
//***** end interface of holo_disp.glfs ***********************************

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

float triangle_intersection(vec3 ro, vec3 rd, vec3 p1, vec3 p2, vec3 p3) {
    // Compute triangle edges
    vec3 e1 = p2 - p1;
    vec3 e2 = p3 - p1;

    // Compute determinant and check for backface culling
    vec3 pvec = cross(rd, e2);
    float det = dot(e1, pvec);
    if (det < 0.000001) return -1.0;

    // Compute distance from the ray origin to the triangle
    vec3 tvec = ro - p1;
    float u = dot(tvec, pvec);
    if (u < 0.0 || u > det) return -1.0;

    // Compute second barycentric coordinate
    vec3 qvec = cross(tvec, e1);
    float v = dot(rd, qvec);
    if (v < 0.0 || u + v > det) return -1.0;

    // Compute distance along the ray to the intersection point
    float t = dot(e2, qvec) / det;

    return t;
}

float intersect(vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out int mat_id) {
	// raytrace
	// float triangle_intersection(in vec3 ro, in vec3 rd, in vec3 p1, in vec3 p2, in vec3 p3) {
	
	float tmin = 1e20;
	nor = vec3(0.0);
	pos = ro + tmin*rd;
	mat_id = -1;
	float h = triangle_intersection(ro, rd, fi.vertex_position[0].xyz, fi.vertex_position[1].xyz, fi.vertex_position[2].xyz);
	
	if(h > 0.0 && h < tmin) {
		tmin = h;
		pos = ro + h*rd;
		nor = fi.normal;
		mat_id = 0; // do texture lookup
	}

	h = triangle_intersection(ro, rd, fi.vertex_position[1].xyz, fi.vertex_position[2].xyz, fi.vertex_position[3].xyz);

	if(h > 0.0 && h < tmin) {
		tmin = h;
		pos = ro + h*rd;
		nor = fi.normal;
		mat_id = 0; // do texture lookup
	}

	// raytrace torus
	// increase numerical stability by first intersecting with a boundign sphere and moving the ray origin closer to the torus

	return tmin;
}

vec3 rayTracePixel(vec3 ro, vec3 rd, out float depth) {
	vec3 pos, nor; // hit position and normal
	vec3 col;
	int mat_id; // material ID
	//float t = intersect(ro, rd, pos, nor, mat_id);
	float t = 0.1;
	col = vec3(1.0, 0, 1.0);
	if(mat_id != -1) {
		// get color and texture coordinates depending on material
		vec4 material = vec4(1.0, 0.1, 0.1, 0.05); // add actual color calculation probabily just take given color
		
		/*
		somehow find out what the color is we collided with
		vec2 uv = get_texcoords(pos, mat_id);
		*/
		
		vec3 albedo = material.rgb;
		
		// lighting - probably not to be hardcoded :|
		//color = compute_illumination(pos, nor, rd, shadow_factor, albedo);
		col = vec3(1.0, 0.1, 0.1);
	}
	
	vec4 pos_clip = get_modelview_projection_matrix() * vec4(pos, 1.0);
	depth = 0.5*(pos_clip.z / pos_clip.w) + 0.5;
	
	return col; 
}

void main()
{
	if (coloring == 0){
		finish_fragment(fi.color, gl_FragCoord.z + fi.depth_offset);
	} else if (coloring == 1) {
		finish_fragment(vec4(fi.normal.xyz, 0.8), gl_FragCoord.z + fi.depth_offset);
	} else if (coloring == 2) {
		vec3 ro[3], rd[3];
		compute_sub_pixel_rays(ro, rd);
		vec3 rgb, depth;

		for (int c = 0; c < 3; c++)
			rgb[c] = rayTracePixel(ro[c], rd[c], depth[c])[c];
		if (!finalize_sub_pixel_fragment(rgb, depth))
			discard;
	}
}