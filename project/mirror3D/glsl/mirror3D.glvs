#version 330 core

//*** altered rgbd_pc_glvs from â€¦project/cgv/libs/rgbd_render/rgbd_pc.glvs ***

#define GEOMETRY_LESS_MODE 0

//***** begin interface of rgbd.glsl ***********************************
uint get_depth_width();
uint get_depth_height();
uint lookup_depth(ivec2 xp);
bool construct_point(in vec2 xp, in float depth, out vec3 p);
bool lookup_color(vec3 p, out vec4 c);
bool lookup_color(vec3 p, float eps, out vec4 c);
//***** end interface of rgbd.glsl ***********************************

//***** begin interface of camera.glsl ***********************************
#define CONVERGENCE 0
#define SUCCESS 0
uniform float inversion_epsilon;
struct calibration
{
	int w;
	int h;
	float max_radius_for_projection;
	vec2 dc;
	float k[6];
	float p[2];
	float skew;
	vec2 c, s;
};
vec2 image_to_pixel_coordinates(in vec2 x, in calibration calib);
vec2 pixel_to_image_coordinates(in vec2 p, in calibration calib);
vec2 texture_to_pixel_coordinates(in vec2 t, in calibration calib);
vec2 pixel_to_texture_coordinates(in vec2 p, in calibration calib);
int apply_distortion_model(in vec2 xd, out vec2 xu, out mat2 J, in calibration calib);
int apply_distortion_model(in vec2 xd, out vec2 xu, out mat2 J, float epsilon, in calibration calib);
int invert_distortion_model(in vec2 xu, inout vec2 xd, bool use_xd_as_initial_guess, in calibration calib);
//***** end interface of camera.glsl ***********************************

uniform calibration depth_calib;

uniform bool geometry_less_rendering = false;
uniform bool do_lookup_color = true;
uniform bool discard_invalid_color_points = true;
uniform vec4 invalid_color = vec4(1.0,0.0,1.0,1.0);
uniform sampler2D depth_image;

in float point_size;
in ivec3 position;
in vec4 color;
in float depth_offset;

out POINT_GS {
	vec4 color;
	float depth_offset;
	vec3 adjacentPositions[4];
} vo;

void main()
{
	ivec2 xp = position.xy;
	uint depth = uint(position.z);
	if (geometry_less_rendering) {
#if GEOMETRY_LESS_MODE == 0
		xp.y = gl_VertexID/int(get_depth_width());
		xp.x = gl_VertexID- xp.y*int(get_depth_width());
#endif
#if GEOMETRY_LESS_MODE == 1
		xp.y = gl_InstanceID;
		xp.x = gl_VertexID;
#endif
#if GEOMETRY_LESS_MODE == 2
		xp.y = gl_InstanceID/int(get_depth_width());
		xp.x = gl_InstanceID - xp.y*int(get_depth_width());
#endif
		depth = lookup_depth(xp);
	}
	vo.depth_offset = depth_offset;
	vec3 p = vec3(0.0);
	if (construct_point(xp, depth, p)) {
		if (do_lookup_color) {
			if (!lookup_color(p, vo.color)) {
				vo.color = invalid_color;
				if (discard_invalid_color_points)
					vo.depth_offset = 200000.0;
			}else{
				
			}
		}
		else
			vo.color = color;
		gl_Position = vec4(p, 1.0);
		gl_PointSize = 1;
	}
	else{
		vo.depth_offset = 200000.0;
	}

	float p0_depth = 65535.0 * texture(depth_image, pixel_to_texture_coordinates(xp+ivec2(0,0), depth_calib)).r;
	float p1_depth = 65535.0 * texture(depth_image, pixel_to_texture_coordinates(xp+ivec2(1,0), depth_calib)).r;
	float p2_depth = 65535.0 * texture(depth_image, pixel_to_texture_coordinates(xp+ivec2(1,1), depth_calib)).r;
	float p3_depth = 65535.0 * texture(depth_image, pixel_to_texture_coordinates(xp+ivec2(0,1), depth_calib)).r;
	
	//texture_to_pixel_coordinates(p0_depth ,depth_calib)

	if (construct_point(xp, p0_depth, p))
		vo.adjacentPositions[0] = p;
	if (construct_point(xp+ivec2(1,0), p1_depth, p))
		vo.adjacentPositions[1] = p;
	if (construct_point(xp+ivec2(0,1), p3_depth, p))
		vo.adjacentPositions[2] = p;
	if (construct_point(xp+ ivec2(1, 1), p2_depth, p))
		vo.adjacentPositions[3] = p;
}